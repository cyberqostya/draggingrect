<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DRAGGABLE</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        height: calc(
          var(--window-inner-height)
        ); /* переменная задастся через JS для истинной 100vh */
        width: 100vw;
        overflow: hidden;
      }

      .border {
        width: 80vw;
        height: 80vh;
        border: 5px solid #314159; /* color of Math.PI */
        background-color: #31415926;
      }

      .rect {
        width: 150px;
        height: 150px;
        background-color: #b73c58; /* color of 2023 PANTONE */
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: Arial, Helvetica, sans-serif;
        color: #fff;
        font-size: 18px;
        user-select: none;
      }

      /* Для отключения скролла на мобильных */
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }
    </style>
  </head>
  <body>
    <div class="modal">
      <div class="border">
        <div class="rect">drag me</div>
      </div>
    </div>
    <script>
      // Для предотвращения скролла на мобильных
      document.documentElement.style.setProperty(
        "--window-inner-height",
        `${window.innerHeight}px`
      );

      // position type = { x: coord, y: coord }
      // Границы передвижения 80% viewport
      class Border {
        constructor(DOMNode) {
          this.block = DOMNode;
          this.borderWidth = parseInt(getComputedStyle(this.block).borderWidth);
          this.coordData = this.block.getBoundingClientRect();
          this.fixCoordData();
        }
        // Из-за CSS толщины border координаты крайних точек немного изменяются
        fixCoordData() {
          const copiedCoordData = JSON.parse(JSON.stringify(this.coordData));

          copiedCoordData.left += this.borderWidth;
          copiedCoordData.top += this.borderWidth;
          copiedCoordData.right -= this.borderWidth;
          copiedCoordData.bottom -= this.borderWidth;

          this.coordData = copiedCoordData;
        }
      }

      // Передвигающийся прямоугольник
      class Rect {
        constructor(DOMNode) {
          this.block = DOMNode;
          this.coordData = this.block.getBoundingClientRect();
          this.position = { x: 0, y: 0 };
          this.lastPosition = { x: 0, y: 0 };
        }
        // Анимация
        setPosition(position) {
          this.position = position;
          this._render();
        }
        _render() {
          this.block.style = `transform: translate(${this.position.x}px, ${this.position.y}px)`;
        }
      }

      // Касание по прямоугольнику
      class Touch {
        constructor() {
          this.startPosition = { x: 0, y: 0 };
        }

        setStartPosition(position) {
          this.startPosition = position;
        }

        // В разных местах clientX и clientY при событии касания и мышки
        getEvent(event) {
          return event.changedTouches ? event.changedTouches[0] : event;
        }
      }

      const border = new Border(document.querySelector(".border"));
      const rect = new Rect(document.querySelector(".rect"));
      const touch = new Touch();

      // Начало перемещения
      function startDragging(deviceEvent) {
        const event = touch.getEvent(deviceEvent); // Клик или Касание

        touch.setStartPosition({ x: event.clientX, y: event.clientY });

        document.body.addEventListener("mousemove", move);
        document.body.addEventListener("mouseup", stopDragging);

        document.body.addEventListener("touchmove", move);
        document.body.addEventListener("touchend", stopDragging);
      }

      // Остановка перемещения
      function stopDragging() {
        rect.lastPosition = rect.position;

        document.body.removeEventListener("mousemove", move);
        document.body.removeEventListener("mouseup", stopDragging);

        document.body.removeEventListener("touchmove", move);
        document.body.removeEventListener("touchend", stopDragging);
      }

      // Передвижение
      function move(deviceEvent) {
        const event = touch.getEvent(deviceEvent); // Клик или Касание

        rect.setPosition(
          checkCollision({
            x: event.clientX - touch.startPosition.x + rect.lastPosition.x,
            y: event.clientY - touch.startPosition.y + rect.lastPosition.y,
          })
        );
      }

      // Проверка столкновения с границей
      function checkCollision(relativePosition) {
        const maxXrelativePosition =
          border.coordData.right - border.coordData.left - rect.coordData.width;
        const maxYrelativePosition =
          border.coordData.bottom -
          border.coordData.top -
          rect.coordData.height;
        const checkedPosition = {
          x:
            relativePosition.x < 0
              ? 0 // position относительно родителя
              : relativePosition.x > maxXrelativePosition
              ? maxXrelativePosition
              : relativePosition.x,
          y:
            relativePosition.y < 0
              ? 0
              : relativePosition.y > maxYrelativePosition
              ? maxYrelativePosition
              : relativePosition.y,
        };
        return checkedPosition;
      }

      // Работа
      rect.block.addEventListener("mousedown", startDragging);
      rect.block.addEventListener("touchstart", startDragging);
    </script>
  </body>
</html>
